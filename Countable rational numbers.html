<!-- [주석단위] #_Part_00100_doctype_and_html -->
<!DOCTYPE html>
<html lang="ko">
<head>
  <!-- [주석단위] #_Part_00200_head_meta_title -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
  <title>유리수의 가산: Calkin–Wilf / Stern–Brocot 트리 시각화 (AI교육연구회 : 위드석)</title>
  <meta name="description" content="유리수의 가산(농도 ℵ₀)을 Calkin–Wilf / Stern–Brocot 트리로 시각화하고, 자연수와 유리수의 일대일 대응을 인터랙티브하게 체험합니다." />

  <!-- [주석단위] #_Part_00300_head_styles_base -->
  <style>
    :root{
      --maxw: min(1280px, 96vw);
      --pad: clamp(12px, 2vw, 18px);
      --gap: clamp(10px, 1.6vw, 16px);
      --radius: 10px;
      --border: 1px solid #e7e7ea;
      --muted: #6b7280;
      --ink: #111827;
      --brand: #577bff;
      --bg: #fafbff;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
      color:var(--ink); background:#ffffff;
    }
    .wrap{
      max-width: var(--maxw); margin: 0 auto; padding: calc(var(--pad) + 6px) var(--pad) 80px;
    }
    h1,h2,h3{margin:0 0 6px}
    p{margin:6px 0 0}
    .bar{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; padding: 14px var(--pad); border:var(--border); border-radius:var(--radius); background:var(--bg);
    }
    .brand{
      font-weight:700; letter-spacing:.1px;
    }
    .brand small{ color:var(--muted); font-weight:600; margin-left:6px}
    .ctrls{
      display:grid; gap: var(--gap);
      grid-template-columns: repeat(12, 1fr);
      padding: var(--pad); border:var(--border); border-radius:var(--radius);
    }
    .ctrls > div{ grid-column: span 12; display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    @media (min-width: 980px){
      .ctrls > .g1 { grid-column: span 7 }
      .ctrls > .g2 { grid-column: span 5 }
      .ctrls > .g3 { grid-column: span 12 }
    }
    label.inline{display:inline-flex; align-items:center; gap:6px}
    select, input[type="number"], input[type="text"]{
      padding:6px 8px; border:1px solid #d8dbe6; border-radius:8px; min-width:70px; background:#fff;
    }
    button.btn{
      padding:8px 12px; border:1px solid #cfd6f7; border-radius:8px; cursor:pointer; background:#f3f6ff;
    }
    button.btn:hover{ background:#eaf0ff}
    .host{
      border:var(--border); border-radius:var(--radius); overflow:hidden; background:#fff;
      height: clamp(420px, 64vh, 720px);
      display:block;
    }
    .panel{
      display:grid; gap: var(--gap);
      grid-template-columns: repeat(12, 1fr);
      margin-top: var(--gap);
    }
    .card{
      grid-column: span 12;
      border:var(--border); border-radius:var(--radius); padding: var(--pad); background:#fff;
    }
    @media (min-width: 1024px){
      .card.half { grid-column: span 6 }
    }
    .muted{ color: var(--muted) }
    .hint{ font-size: 12px; color:#80859a }
    .kbd{ padding:1px 6px; border:1px solid #d9dce8; border-radius:6px; background:#f6f8ff; font-size:12px}
    .tbl{
      width:100%; border-collapse: collapse; font-variant-numeric: tabular-nums;
    }
    .tbl th,.tbl td{ border-bottom: 1px solid #f0f1f6; padding:8px 6px; text-align:left; }
    .tbl th{ background:#fafbff; position:sticky; top:0; z-index:1}
    .scroll{ max-height: 280px; overflow:auto; border:1px solid #f0f1f6; border-radius:8px}
    .ok{ color:#0a7c2e; font-weight:700}
    .warn{ color:#a45500; font-weight:700}

    /* SVG theming from user’s original */
    .node-label{
      font-size: 12px; fill:#222; text-anchor: middle; dominant-baseline: middle; pointer-events:none
    }
    .node-rect{
      fill:#fdfdfd; stroke:#c8d4ff; stroke-width:1.2; rx:6; ry:6;
      filter: drop-shadow(0 1px .6px rgba(0,0,0,.06));
    }
    .edge-line{ stroke:#b8c2d6; stroke-width:1.2; }
    .node:hover .node-rect{ stroke:#7da1ff; stroke-width:1.8; }
    .badge{ font-size:11px; fill:#666 }
    .node.hl .node-rect{ stroke:#ec4899; stroke-width:2.1; fill:#fff0fb }
  </style>
</head>
<body>
  <!-- [주석단위] #_Part_00400_header -->
  <header class="wrap">
    <div class="bar">
      <div class="brand">유리수의 가산 (농도 <span style="font-family:'Times New Roman',serif">ℵ₀</span>) <small>AI교육연구회 : 위드석</small></div>
      <div class="hint">노트북 화면에 자동 맞춤 · SVG 저장 가능</div>
    </div>
  </header>

  <!-- [주석단위] #_Part_00500_main_visualizer -->
  <main class="wrap">
    <section class="ctrls" id="ctrls">
      <div class="g1">
        <label class="inline"><input type="radio" name="treeType" value="cw" checked> Calkin–Wilf</label>
        <label class="inline"><input type="radio" name="treeType" value="sb"> Stern–Brocot</label>

        <label class="inline">단계(깊이)
          <select id="depthSel">
            <option>1</option><option>2</option><option>3</option>
            <option selected>4</option><option>5</option><option>6</option><option>7</option><option>8</option>
          </select>
        </label>

        <label class="inline">노드 폭
          <input id="nodeW" type="number" value="64" min="40" max="110" step="2">
        </label>
        <label class="inline">노드 높이
          <input id="nodeH" type="number" value="28" min="22" max="70" step="2">
        </label>

        <button class="btn" id="btnRedraw">다시 그리기</button>
        <button class="btn" id="btnFit">화면 맞춤</button>
        <button class="btn" id="btnSave">SVG 저장</button>
      </div>

      <div class="g2">
        <label class="inline">분수 검색 a/b
          <input id="findFrac" type="text" placeholder="예: 2/5" style="min-width:90px">
        </label>
        <button class="btn" id="btnFind">찾아 하이라이트</button>
        <small class="hint">※ 현재 표시된 깊이(단계) 안에서 검색</small>
      </div>

      <div class="g3 muted" style="line-height:1.5">
        <b>Calkin–Wilf:</b> 노드 a/b의 자식은 a/(a+b), (a+b)/b · <b>Stern–Brocot:</b> 경계(0/1, 1/0)에서 mediant (a+c)/(b+d)로 확장 · 두 트리 모두 <u>양의 유리수를 기약분수로 정확히 1번씩</u> 포함합니다.
      </div>
    </section>

    <section class="host" id="host">
      <svg id="treeSVG" viewBox="0 0 1200 680" preserveAspectRatio="xMidYMin meet" style="width:100%;height:100%;display:block"></svg>
    </section>

    <!-- [주석단위] #_Part_00600_panels_bijection_and_table -->
    <section class="panel">
      <article class="card half">
        <h2 style="margin-bottom:8px">ℕ ↔ ℚ⁺ 일대일 대응 (가산성 체험)</h2>
        <p class="muted" style="margin-bottom:10px">이 도구는 Calkin–Wilf 트리의 **경로를 2진수**에 대응시켜 자연수와 유리수(양의) 사이에 **1:1 대응**을 보여줍니다.</p>
        <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:10px">
          <label class="inline">자연수 n (≥1)
            <input id="nInput" type="number" value="1" min="1" step="1" style="width:110px">
          </label>
          <button class="btn" id="btnN2Q">n → a/b</button>
          <label class="inline">분수 a/b
            <input id="abInput" type="text" value="1/1" style="width:120px">
          </label>
          <button class="btn" id="btnQ2N">a/b → n</button>
          <button class="btn" id="btnMark">트리에서 표시</button>
        </div>
        <div id="mapOut" class="muted" style="line-height:1.6"></div>
        <p class="hint" style="margin-top:8px">
          이진 경로 규칙: n의 2진표기에서 맨 앞의 1을 버리고, <span class="kbd">0</span>은 왼쪽(L), <span class="kbd">1</span>은 오른쪽(R)으로 내려가면 a/b 도달.
        </p>
      </article>

      <article class="card half">
        <h2 style="margin-bottom:8px">처음 N개의 양의 유리수 (CW 열거)</h2>
        <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px">
          <label class="inline">N
            <input id="listN" type="number" value="32" min="1" max="2048" step="1" style="width:110px">
          </label>
          <button class="btn" id="btnList">목록 만들기</button>
          <small class="muted">※ Calkin–Wilf 열거 순서(중복 없음)</small>
        </div>
        <div class="scroll">
          <table class="tbl" id="listTbl">
            <thead><tr><th style="width:80px">n</th><th style="width:120px">a/b</th><th>십진(≈)</th><th>경로(L/R)</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </article>

      <article class="card">
        <details open>
          <summary style="cursor:pointer; font-weight:700">왜 “가산(ℵ₀)”인가? (증명 스케치)</summary>
          <div style="margin-top:8px; line-height:1.7">
            <ol style="margin:0; padding-left:18px">
              <li><b>Calkin–Wilf 트리 사실:</b> 루트 1/1에서 시작해 자식 규칙 a/(a+b), (a+b)/b를 반복하면 모든 <u>양의 유리수</u>가 <u>기약분수로 정확히 한 번</u> 나타납니다.</li>
              <li><b>경로와 2진수:</b> 루트를 ‘1’로 두고 왼쪽은 ‘0’, 오른쪽은 ‘1’로 표기하면, 각 노드는 <u>유일한 이진 경로</u>를 가집니다. 루트의 앞자리 1만 떼면 자연수의 2진수와 일치시킬 수 있어 <u>ℕ과 일대일 대응</u>이 됩니다.</li>
              <li><b>결론:</b> 양의 유리수 집합은 가산 무한입니다. 0과 음수는 간단히 끼워넣을 수 있어 전체 유리수 ℚ 역시 가산입니다.</li>
            </ol>
            <p class="hint">Stern–Brocot도 비슷한 아이디어(중간분수 mediant)로 모든 양의 유리수를 한 번씩 나열합니다.</p>
          </div>
        </details>
      </article>
    </section>
  </main>

  <!-- [주석단위] #_Part_00700_footer_required_4 -->
  <footer class="wrap" style="margin-top:20px">
    <div class="bar" style="justify-content:center; gap:16px; flex-wrap:wrap">
      <div>ⓒ 2025 AI교육연구회 withseok. All rights reserved. (위드석)</div>
      <div>비상업적 이용만 허용됩니다.</div>
      <div><a href="https://withseok.tistory.com/606" target="_blank" rel="noopener">위드석</a> · <a href="https://aiers.kr" target="_blank" rel="noopener">AI교육연구회</a></div>
    </div>
  </footer>

  <!-- [주석단위] #_Part_00800_scripts_utils -->
  <script>
  (function(){
    'use strict';

    // ---------- 공통 유틸 ----------
    const $ = (sel, root=document)=>root.querySelector(sel);
    const $$ = (sel, root=document)=>[...root.querySelectorAll(sel)];
    const gcd = (a,b)=>{ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b, a%b] } return a||1; };
    const simp = (n,d)=>{ const g=gcd(n,d); return [n/g, d/g]; };
    const mediant = (a,b,c,d)=>[a+c, b+d];

    // 숫자/분수 파싱
    function parseFrac(txt){
      if(!txt) return null;
      const s = String(txt).trim();
      const m = s.match(/^(-?\d+)\s*\/\s*(-?\d+)$/);
      if(!m) return null;
      let a = parseInt(m[1],10), b = parseInt(m[2],10);
      if(b===0) return null;
      const sign = (b<0 ? -1 : 1);
      a *= sign; b *= sign;
      const [nn,dd] = simp(a,b);
      return [nn,dd];
    }

    // ---------- 트리 생성 ----------
    function genCW(depth){
      const lvls=[]; let id=0;
      const root = {id:id++, n:1, d:1, depth:0, pid:null};
      lvls.push([root]);
      for(let lv=0; lv<depth; lv++){
        const cur = lvls[lv], nxt=[];
        for(const p of cur){
          const a=p.n,b=p.d;
          nxt.push({id:id++, n:a,   d:a+b, depth:lv+1, pid:p.id});
          nxt.push({id:id++, n:a+b, d:b,   depth:lv+1, pid:p.id});
        }
        lvls.push(nxt);
      }
      return lvls;
    }
    function genSB(depth){
      const lvls=[]; let id=0;
      const root = {id:id++, n:1,d:1, depth:0, pid:null, La:0,Lb:1, Ra:1,Rb:0};
      lvls.push([root]);
      for(let lv=0; lv<depth; lv++){
        const cur=lvls[lv], nxt=[];
        for(const p of cur){
          const [ln,ld]=mediant(p.La,p.Lb,p.n,p.d);
          const [rn,rd]=mediant(p.n,p.d,p.Ra,p.Rb);
          let L={id:id++, n:ln,d:ld, depth:lv+1, pid:p.id, La:p.La,Lb:p.Lb, Ra:p.n,Rb:p.d};
          let R={id:id++, n:rn,d:rd, depth:lv+1, pid:p.id, La:p.n,Lb:p.d, Ra:p.Ra,Rb:p.Rb};
          [L.n,L.d]=simp(L.n,L.d); [R.n,R.d]=simp(R.n,R.d);
          nxt.push(L,R);
        }
        lvls.push(nxt);
      }
      return lvls;
    }

    // ---------- 렌더 ----------
    const host = $('#host');
    const svg  = $('#treeSVG');

    let NODE_W = 64, NODE_H = 28;

    function render(levels){
      const L = levels.length;
      const width  = host.clientWidth || 1200;
      // 단계수·노드크기에 따라 세로 간격 가변
      const baseGap = Math.max(90, Math.min(140, Math.floor(width/10)));
      const layerGap = Math.round(baseGap * (NODE_H/28) * 0.95);
      const height = 24 + L*NODE_H + (L-1)*layerGap + 24;

      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      while(svg.firstChild) svg.removeChild(svg.firstChild);

      // 좌표 계산
      const id2pt = new Map();
      for(let lv=0; lv<L; lv++){
        const row = levels[lv], n=row.length;
        const usable = width - 40*2;
        const y = 28 + lv*(layerGap+NODE_H) + NODE_H/2;
        for(let i=0;i<n;i++){
          const x = 40 + (i+1)*(usable/(n+1));
          id2pt.set(row[i].id, {x,y});
        }
      }

      // 간선
      for(let lv=1; lv<L; lv++){
        for(const node of levels[lv]){
          const p = id2pt.get(node.pid), c = id2pt.get(node.id);
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', p.x);
          line.setAttribute('y1', p.y + NODE_H/2 - NODE_H/2);
          line.setAttribute('x2', c.x);
          line.setAttribute('y2', c.y - NODE_H/2 + NODE_H/2);
          line.setAttribute('class','edge-line');
          svg.appendChild(line);
        }
      }

      // 노드
      for(let lv=0; lv<L; lv++){
        for(const node of levels[lv]){
          const {x,y} = id2pt.get(node.id);
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('class','node');
          g.setAttribute('transform', `translate(${x - NODE_W/2}, ${y - NODE_H/2})`);
          g.dataset.frac = `${node.n}/${node.d}`;

          const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
          rect.setAttribute('width', NODE_W);
          rect.setAttribute('height', NODE_H);
          rect.setAttribute('class','node-rect');

          const label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('x', NODE_W/2);
          label.setAttribute('y', NODE_H/2 + .6);
          label.setAttribute('class','node-label');
          label.textContent = `${node.n}/${node.d}`;

          const title = document.createElementNS('http://www.w3.org/2000/svg','title');
          title.textContent = `분수: ${node.n}/${node.d} (단계 ${node.depth})`;

          g.appendChild(rect); g.appendChild(label); g.appendChild(title);
          svg.appendChild(g);
        }
      }

      // 배지
      const b = document.createElementNS('http://www.w3.org/2000/svg','text');
      b.setAttribute('x', width-8); b.setAttribute('y', height-10);
      b.setAttribute('text-anchor','end'); b.setAttribute('class','badge');
      b.textContent = 'AI교육연구회 : 위드석';
      svg.appendChild(b);
    }

    // ---------- 컨트롤·상태 ----------
    const depthSel = $('#depthSel');
    const nodeW = $('#nodeW'); const nodeH = $('#nodeH');
    const btnRedraw = $('#btnRedraw'); const btnFit = $('#btnFit'); const btnSave = $('#btnSave');

    function currentType(){ return ($$('input[name="treeType"]').find(r=>r.checked)||{}).value || 'cw' }
    function buildLevels(){
      const d = parseInt(depthSel.value,10);
      return currentType()==='cw' ? genCW(d) : genSB(d);
    }
    function redraw(){
      NODE_W = Math.max(40, Math.min(110, parseInt(nodeW.value,10)||64));
      NODE_H = Math.max(22, Math.min(70,  parseInt(nodeH.value,10)||28));
      clearHL();
      render(buildLevels());
    }

    // ---------- 검색/하이라이트 ----------
    const findFrac = $('#findFrac'); const btnFind = $('#btnFind');
    function clearHL(){ $$('.node.hl', svg).forEach(n=>n.classList.remove('hl')); }
    function highlight(ab){
      clearHL();
      const target = $(`.node[data-frac="${ab}"]`, svg);
      if(target){ target.classList.add('hl'); return true; }
      return false;
    }
    btnFind.addEventListener('click', ()=>{
      const f = parseFrac(findFrac.value);
      if(!f){ alert('a/b 형태로 입력하세요 (분모 0 불가)'); return; }
      const ab = `${f[0]}/${f[1]}`;
      if(!highlight(ab)) alert('현재 단계 안에서 찾을 수 없습니다. 깊이를 늘려보세요.');
    });

    // ---------- ℕ ↔ ℚ⁺ (Calkin–Wilf 경로 2진수) ----------
    // n → frac
    function nToFrac(n){
      // n>=1, binary path (drop leading 1)
      let a=1, b=1;
      const bits = n.toString(2).slice(1);
      for(const bit of bits){
        if(bit==='0'){ // left: a/(a+b)
          b = a + b;
        }else{ // right: (a+b)/b
          a = a + b;
        }
      }
      return [a,b];
    }
    // frac → n  (반복적 유클리드: 1/1로 거슬러 올라가며 L/R 기록)
    function fracToN(a,b){
      [a,b] = simp(a,b);
      if(a<=0 || b<=0) return null; // 양의 유리수만
      const path=[]; // L=0, R=1
      while(!(a===1 && b===1)){
        if(a>b){ a = a-b; path.push('1'); } // R
        else    { b = b-a; path.push('0'); } // L
      }
      const bits = '1' + path.reverse().join('');
      return parseInt(bits, 2);
    }

    const nInput = $('#nInput'), abInput=$('#abInput');
    const btnN2Q=$('#btnN2Q'), btnQ2N=$('#btnQ2N'), btnMark=$('#btnMark');
    const mapOut = $('#mapOut');

    btnN2Q.addEventListener('click', ()=>{
      const n = parseInt(nInput.value,10);
      if(!(n>=1)){ alert('n은 1 이상의 자연수'); return; }
      const [a,b] = nToFrac(n);
      const path = n.toString(2).slice(1).replace(/0/g,'L').replace(/1/g,'R') || '(루트)';
      abInput.value = `${a}/${b}`;
      mapOut.innerHTML = `n = <b>${n}</b> <span class="muted">(${n.toString(2)}₂)</span> → a/b = <b>${a}/${b}</b> · 경로 <b>${path}</b>`;
    });

    btnQ2N.addEventListener('click', ()=>{
      const f = parseFrac(abInput.value);
      if(!f){ alert('a/b 형태로 입력'); return; }
      const [a,b]=f;
      if(a<=0||b<=0){ alert('양의 유리수만 (a>0, b>0)'); return; }
      const n = fracToN(a,b);
      const path = n.toString(2).slice(1).replace(/0/g,'L').replace(/1/g,'R') || '(루트)';
      nInput.value = n;
      mapOut.innerHTML = `a/b = <b>${a}/${b}</b> → n = <b>${n}</b> <span class="muted">(${n.toString(2)}₂)</span> · 경로 <b>${path}</b>`;
    });

    btnMark.addEventListener('click', ()=>{
      const f = parseFrac(abInput.value);
      if(!f){ alert('a/b 형태로 입력'); return; }
      const [a,b]=f, ab=`${a}/${b}`;
      if(!highlight(ab)){
        alert('현재 트리 깊이에서 보이지 않습니다. 단계(깊이)를 늘린 뒤 다시 표시해보세요.');
      }
    });

    // ---------- 목록(처음 N개) ----------
    const listN = $('#listN'); const btnList = $('#btnList'); const listTbl = $('#listTbl tbody');
    function buildList(N){
      const rows = [];
      for(let n=1;n<=N;n++){
        const [a,b]=nToFrac(n);
        const path = n.toString(2).slice(1).replace(/0/g,'L').replace(/1/g,'R') || '–';
        rows.push(`<tr><td>${n}</td><td>${a}/${b}</td><td>${(a/b).toFixed(6)}</td><td>${path}</td></tr>`);
      }
      listTbl.innerHTML = rows.join('');
    }
    btnList.addEventListener('click', ()=>{
      const N = Math.min(2048, Math.max(1, parseInt(listN.value,10)||32));
      buildList(N);
    });
    // 초기 표
    buildList(parseInt(listN.value,10));

    // ---------- 저장/화면맞춤/이벤트 ----------
    function saveSVG(){
      const src = '<?xml version="1.0" encoding="UTF-8"?>\n' + new XMLSerializer().serializeToString(svg);
      const blob = new Blob([src], {type:'image/svg+xml'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'rationals_tree.svg';
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
    }
    btnSave.addEventListener('click', saveSVG);

    function fitHeight(){
      // 노트북에서 보기 좋은 높이로 즉시 맞춤
      const vh = Math.max(420, Math.min(720, Math.round(window.innerHeight * 0.66)));
      host.style.height = vh + 'px';
      redraw();
    }
    btnFit.addEventListener('click', fitHeight);

    // 다시그리기/리사이즈
    btnRedraw.addEventListener('click', redraw);
    depthSel.addEventListener('change', redraw);
    nodeW.addEventListener('change', redraw);
    nodeH.addEventListener('change', redraw);
    $$('input[name="treeType"]').forEach(r=>r.addEventListener('change', redraw));
    window.addEventListener('resize', ()=>{ redraw(); });

    // 초기 렌더
    redraw();
  })();
  </script>
</body>
</html>
