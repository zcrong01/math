<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
  <title>신기한 유리수 나무: Calkin–Wilf / Stern–Brocot 트리 시각화 (AI교육연구회 : 위드석)</title>
  <meta name="description" content="모든 유리수가 딱 한 번씩만 나타나는 신기한 나무를 탐험하며, 자연수와 유리수의 일대일 대응(가산성)을 체험합니다." />

  <style>
    :root {
      --font-sans: "Pretendard Variable", Pretendard, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      
      /* Light Mode Colors */
      --bg: #f8f9fa;
      --bg-card: #ffffff;
      --ink: #212529;
      --ink-muted: #6c757d;
      --border: #dee2e6;
      --brand: #4c6ef5;
      --brand-light: #edf2ff;
      --brand-dark: #364fc7;
      --highlight-bg: #fff0f6;
      --highlight-stroke: #f06595;
      
      /* Sizing */
      --maxw: 1280px;
      --pad: clamp(16px, 2.2vw, 24px);
      --gap: clamp(12px, 1.8vw, 20px);
      --radius: 12px;
      --shadow: 0 4px 6px -1px rgba(0,0,0,.07), 0 2px 4px -2px rgba(0,0,0,.05);
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #121212;
        --bg-card: #1e1e1e;
        --ink: #e9ecef;
        --ink-muted: #adb5bd;
        --border: #495057;
        --brand: #748ffc;
        --brand-light: #232946;
        --brand-dark: #91a7ff;
        --highlight-bg: #381a28;
        --highlight-stroke: #ff87ab;
      }
    }

    * { box-sizing: border-box; }
    html { font-size: 16px; scroll-behavior: smooth; }
    body {
      margin: 0;
      font-family: var(--font-sans);
      color: var(--ink);
      background-color: var(--bg);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .wrap {
      max-width: var(--maxw);
      margin: 0 auto;
      padding: var(--gap);
    }
    h1, h2, h3 { margin: 0 0 8px; font-weight: 700; }
    h2 { font-size: 1.25rem; }
    p { margin: 0; line-height: 1.65; }

    .bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      padding: 1rem var(--pad);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background-color: var(--bg-card);
      box-shadow: var(--shadow);
    }
    .brand { font-size: 1.1rem; font-weight: 700; letter-spacing: -.2px; }
    .brand small { color: var(--ink-muted); font-weight: 500; margin-left: 8px; font-size: 0.9rem; }

    .card {
      background-color: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--pad);
      box-shadow: var(--shadow);
    }
    .ctrls {
      display: grid;
      gap: var(--gap);
      grid-template-columns: 1fr;
      margin-top: var(--gap);
    }
    @media (min-width: 980px) {
      .ctrls { grid-template-columns: repeat(12, 1fr); }
      .ctrls > .g1 { grid-column: span 7; }
      .ctrls > .g2 { grid-column: span 5; }
    }
    .ctrls-group {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
    }

    label.inline { display: inline-flex; align-items: center; gap: 8px; font-size: 0.95rem; }
    input[type="radio"] { accent-color: var(--brand); }
    select, input[type="number"], input[type="text"] {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      min-width: 80px;
      background-color: var(--bg-card);
      color: var(--ink);
      font-size: 0.95rem;
      transition: border-color .2s, box-shadow .2s;
    }
    select:focus, input:focus {
      outline: none;
      border-color: var(--brand);
      box-shadow: 0 0 0 3px var(--brand-light);
    }
    button.btn {
      padding: 9px 16px;
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      background-color: var(--bg-card);
      color: var(--ink);
      font-weight: 600;
      font-size: 0.95rem;
      transition: background-color .2s, transform .1s, border-color .2s, color .2s;
    }
    button.btn:hover { background-color: var(--brand-light); border-color: var(--brand); color: var(--brand-dark); }
    button.btn:active { transform: translateY(1px); }
    button.primary { background-color: var(--brand); color: white; border-color: var(--brand); }
    button.primary:hover { background-color: var(--brand-dark); border-color: var(--brand-dark); color: white; }

    .host {
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      background-color: var(--bg-card);
      box-shadow: var(--shadow);
      height: clamp(450px, 65vh, 720px);
      margin-top: var(--gap);
    }
    .panel {
      display: grid;
      gap: var(--gap);
      grid-template-columns: 1fr;
      margin-top: var(--gap);
    }
    @media (min-width: 1024px) {
      .panel { grid-template-columns: repeat(2, 1fr); }
      .panel .card.full { grid-column: 1 / -1; }
    }
    .muted { color: var(--ink-muted); }
    .hint { font-size: 0.85rem; color: var(--ink-muted); }
    .kbd { padding: 2px 8px; border: 1px solid var(--border); border-radius: 6px; background-color: var(--bg); font-family: monospace; font-size: 0.85rem; }
    
    .tbl { width: 100%; border-collapse: collapse; font-variant-numeric: tabular-nums; }
    .tbl th, .tbl td { border-bottom: 1px solid var(--border); padding: 10px 8px; text-align: left; }
    .tbl th { background-color: var(--bg); position: sticky; top: 0; z-index: 1; font-weight: 600; font-size: 0.9rem; }
    .tbl tbody tr:nth-child(even) { background-color: var(--bg); }
    .scroll { max-height: 280px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px; }
    
    summary { cursor: pointer; font-weight: 700; transition: color .2s; }
    summary:hover { color: var(--brand); }
    
    /* SVG theming */
    .node { cursor: pointer; }
    .node-label { font-size: 12px; fill: var(--ink); text-anchor: middle; dominant-baseline: middle; pointer-events: none; font-weight: 500; }
    .node-rect {
      fill: var(--bg-card);
      stroke: var(--brand);
      stroke-opacity: 0.6;
      stroke-width: 1.2;
      rx: 8; ry: 8;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,.1));
      transition: stroke .2s, stroke-width .2s, fill .2s;
    }
    .edge-line { stroke: var(--border); stroke-width: 1.2; }
    .node:hover .node-rect { stroke: var(--brand); stroke-opacity: 1; stroke-width: 2; }
    .badge { font-size: 11px; fill: var(--ink-muted); }
    .node.hl .node-rect { stroke: var(--highlight-stroke); stroke-width: 2.5; fill: var(--highlight-bg); }
  </style>
</head>
<body>
  <header class="wrap">
    <div class="bar">
      <div class="brand">신기한 유리수 나무 <small>AI교육연구회 : 위드석</small></div>
      <div class="hint">SVG 저장 · 화면 자동 맞춤</div>
    </div>
  </header>

  <main class="wrap" style="padding-top:0;">
    <section class="card ctrls" id="ctrls">
      <div class="g1 ctrls-group">
        <label class="inline"><input type="radio" name="treeType" value="cw" checked> 칼킨-윌프</label>
        <label class="inline"><input type="radio" name="treeType" value="sb"> 스턴-브로콧</label>
        <span style="width:1px; height:20px; background:var(--border); margin:0 8px;"></span>
        <label class="inline">깊이 <select id="depthSel">
          <option>1</option><option>2</option><option>3</option>
          <option selected>4</option><option>5</option><option>6</option><option>7</option><option>8</option>
        </select></label>
        <label class="inline">노드 폭 <input id="nodeW" type="number" value="60" min="40" max="110" step="2"></label>
        <label class="inline">노드 높이 <input id="nodeH" type="number" value="28" min="22" max="70" step="2"></label>
        <button class="btn" id="btnRedraw">다시 그리기</button>
        <button class="btn" id="btnFit">화면 맞춤</button>
        <button class="btn" id="btnSave">SVG 저장</button>
      </div>
      <div class="g2 ctrls-group">
        <label class="inline">분수 검색 <input id="findFrac" type="text" placeholder="예: 2/5" style="min-width:100px"></label>
        <button class="btn primary" id="btnFind">찾기</button>
      </div>
    </section>
    
    <div class="card muted" style="margin-top:var(--gap); font-size:0.9rem; line-height:1.6;">
        <b>칼킨-윌프(Calkin-Wilf) 나무:</b> 부모(<code>a/b</code>)가 자식(<code>a/(a+b)</code> 와 <code>(a+b)/b</code>)을 낳는 간단한 규칙으로 만들어져요. <br><b>스턴-브로콧(Stern-Brocot) 나무:</b> 두 분수 사이에 새로운 분수를 끼워 넣는 방식으로 자라나요. 두 나무 모두 모든 양의 유리수를 딱 한 번씩만 품고 있는 아주 특별한 나무랍니다!
    </div>

    <section class="host" id="host">
      <svg id="treeSVG" viewBox="0 0 1200 680" preserveAspectRatio="xMidYMin meet" style="width:100%;height:100%;display:block"></svg>
    </section>

    <section class="panel">
      <article class="card">
        <h2 style="margin-bottom:12px">자연수와 분수의 1:1 암호 교환 🤝</h2>
        <p class="muted" style="margin-bottom:16px; font-size:0.95rem;">모든 자연수는 자신만의 짝꿍 분수를, 모든 분수는 자신만의 짝꿍 자연수를 갖고 있어요. 이 나무는 그 비밀스러운 짝을 찾아준답니다. 나무의 노드를 직접 클릭해서 경로를 확인해보세요!</p>
        <div style="display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-bottom:12px">
          <label class="inline">자연수 n <input id="nInput" type="number" value="1" min="1" step="1" style="width:110px"></label>
          <button class="btn" id="btnN2Q">→ 분수로</button>
          <label class="inline">분수 a/b <input id="abInput" type="text" value="1/1" style="width:110px"></label>
          <button class="btn" id="btnQ2N">→ 자연수로</button>
        </div>
        <div id="mapOut" class="muted" style="line-height:1.6; padding:10px; border-radius:8px; background:var(--bg); min-height:48px; transition: background-color .3s;">
          이곳에 자연수-분수 변환 결과와 경로가 표시됩니다.
        </div>
        <p class="hint" style="margin-top:12px">
          <b>암호 규칙:</b> 자연수를 2진수로 바꿔요. 맨 앞 '1'은 출발 신호! 그 뒤부터 <span class="kbd">0</span>은 왼쪽, <span class="kbd">1</span>은 오른쪽 길로 따라가면... 짠! 짝꿍 분수가 기다리고 있답니다.
        </p>
      </article>

      <article class="card">
        <h2 style="margin-bottom:12px">유리수 줄 세우기 🔢</h2>
        <div style="display:flex; gap:10px; align-items:center; margin-bottom:16px">
          <label class="inline">개수 N <input id="listN" type="number" value="32" min="1" max="2048" step="1" style="width:100px"></label>
          <button class="btn" id="btnList">목록 생성</button>
        </div>
        <div class="scroll">
          <table class="tbl" id="listTbl">
            <thead><tr><th style="width:80px">번호(n)</th><th style="width:120px">분수(a/b)</th><th>소수(≈)</th><th>경로</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </article>

      <article class="card full">
        <details open>
          <summary>🤔 유리수는 왜 "셀 수 있다"고 말할까요? (가산 이야기)</summary>
          <div style="margin-top:12px; line-height:1.75; padding-left:8px;">
            <ol style="margin:0; padding-left:20px;">
              <li><b>빠짐없이, 겹치지 않게!</b><br>이 나무에는 세상의 모든 양의 분수(양의 유리수)가 **빠짐없이 딱 한 번씩만** 나타나요. 마치 우리 반 친구들이 한 명도 빠짐없이, 한 줄로 서 있는 것과 같아요.</li>
              <li><b>모든 분수에 번호 붙이기!</b><br>나무의 모든 분수는 꼭대기(1/1)에서부터 내려오는 **자신만의 고유한 길(경로)**을 가져요. 이 길을 '왼쪽은 0, 오른쪽은 1'처럼 암호로 바꿀 수 있죠. 이 암호 덕분에 우리는 모든 분수에 '1번 분수', '2번 분수', '3번 분수'... 처럼 자연수 번호를 끝없이 붙여줄 수 있답니다.</li>
              <li><b>'셀 수 있는 무한'의 의미</b><br>자연수처럼 번호를 하나씩 붙여서 셀 수 있는 무한을 수학에서는 **'가산 무한(Countable Infinity)'**이라고 불러요. 그래서 유리수는 셀 수 있는 무한집합이에요. 무한히 많긴 하지만, 자연수와 '같은 급'의 무한인 셈이죠!</li>
            </ol>
          </div>
        </details>
      </article>
    </section>
  </main>

  <footer class="wrap" style="padding-bottom:2rem;">
    <div class="bar" style="justify-content:center; gap:20px; flex-wrap:wrap; box-shadow:none; background:transparent; border:none; font-size:0.9rem; color:var(--ink-muted);">
      <div>ⓒ 2025 AI교육연구회 withseok. All rights reserved. (위드석)</div>
      <div style="display:flex; gap:20px;">
        <a href="https://withseok.tistory.com/606" target="_blank" rel="noopener" style="color:inherit;">위드석</a>
        <a href="https://aiers.kr" target="_blank" rel="noopener" style="color:inherit;">AI교육연구회</a>
      </div>
    </div>
  </footer>

  <script>
  (function(){
    'use strict';

    // ---------- 공통 유틸 ----------
    const $ = (sel, root=document)=>root.querySelector(sel);
    const $$ = (sel, root=document)=>[...root.querySelectorAll(sel)];
    const gcd = (a,b)=>{ a=Math.abs(a); b=Math.abs(b); while(b){ [a,b]=[b, a%b] } return a||1; };
    const simp = (n,d)=>{ const g=gcd(n,d); return [n/g, d/g]; };
    const mediant = (a,b,c,d)=>[a+c, b+d];

    function parseFrac(txt){
      if(!txt) return null;
      const s = String(txt).trim();
      const m = s.match(/^(-?\d+)\s*\/\s*(-?\d+)$/);
      if(!m) return null;
      let a = parseInt(m[1],10), b = parseInt(m[2],10);
      if(b===0) return null;
      const sign = (b<0 ? -1 : 1);
      a *= sign; b *= sign;
      const [nn,dd] = simp(a,b);
      return [nn,dd];
    }

    // ---------- 트리 생성 ----------
    function genCW(depth){
      const lvls=[]; let id=0;
      const root = {id:id++, n:1, d:1, depth:0, pid:null};
      lvls.push([root]);
      for(let lv=0; lv<depth; lv++){
        const cur = lvls[lv], nxt=[];
        for(const p of cur){
          const a=p.n,b=p.d;
          nxt.push({id:id++, n:a,   d:a+b, depth:lv+1, pid:p.id});
          nxt.push({id:id++, n:a+b, d:b,   depth:lv+1, pid:p.id});
        }
        lvls.push(nxt);
      }
      return lvls;
    }
    function genSB(depth){
      const lvls=[]; let id=0;
      const root = {id:id++, n:1,d:1, depth:0, pid:null, La:0,Lb:1, Ra:1,Rb:0};
      lvls.push([root]);
      for(let lv=0; lv<depth; lv++){
        const cur=lvls[lv], nxt=[];
        for(const p of cur){
          const [ln,ld]=mediant(p.La,p.Lb,p.n,p.d);
          const [rn,rd]=mediant(p.n,p.d,p.Ra,p.Rb);
          let L={id:id++, n:ln,d:ld, depth:lv+1, pid:p.id, La:p.La,Lb:p.Lb, Ra:p.n,Rb:p.d};
          let R={id:id++, n:rn,d:rd, depth:lv+1, pid:p.id, La:p.n,Lb:p.d, Ra:p.Ra,Rb:p.Rb};
          [L.n,L.d]=simp(L.n,L.d); [R.n,R.d]=simp(R.n,R.d);
          nxt.push(L,R);
        }
        lvls.push(nxt);
      }
      return lvls;
    }

    // ---------- 렌더 ----------
    const host = $('#host');
    const svg  = $('#treeSVG');
    let NODE_W = 60, NODE_H = 28;

    function render(levels){
      const L = levels.length;
      const width  = host.clientWidth || 1200;
      // -- 세로 간격 조정 --
      const layerGap = Math.max(20, NODE_H * 1.4);
      const height = 30 + L*NODE_H + (L-1)*layerGap;

      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.innerHTML = '';

      const id2pt = new Map();
      for(let lv=0; lv<L; lv++){
        const row = levels[lv], n=row.length;
        const usable = width - 2 * NODE_W; // 양쪽 여백
        const y = 15 + NODE_H/2 + lv*(layerGap+NODE_H);
        for(let i=0;i<n;i++){
          const x = NODE_W + (n > 1 ? i * (usable / (n - 1)) : usable / 2);
          id2pt.set(row[i].id, {x,y});
        }
      }

      const edgesFrag = document.createDocumentFragment();
      for(let lv=1; lv<L; lv++){
        for(const node of levels[lv]){
          const p = id2pt.get(node.pid), c = id2pt.get(node.id);
          const line = document.createElementNS('http://www.w3.org/2000/svg','line');
          line.setAttribute('x1', p.x); line.setAttribute('y1', p.y);
          line.setAttribute('x2', c.x); line.setAttribute('y2', c.y);
          line.setAttribute('class','edge-line');
          edgesFrag.appendChild(line);
        }
      }
      svg.appendChild(edgesFrag);

      const nodesFrag = document.createDocumentFragment();
      for(let lv=0; lv<L; lv++){
        for(const node of levels[lv]){
          const {x,y} = id2pt.get(node.id);
          const g = document.createElementNS('http://www.w3.org/2000/svg','g');
          g.setAttribute('class','node');
          g.setAttribute('transform', `translate(${x - NODE_W/2}, ${y - NODE_H/2})`);
          g.dataset.frac = `${node.n}/${node.d}`;
          
          // -- 클릭 이벤트 추가 --
          g.addEventListener('click', () => showPathForNode(node.n, node.d));

          const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
          rect.setAttribute('width', NODE_W); rect.setAttribute('height', NODE_H);
          rect.setAttribute('class','node-rect');

          const label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('x', NODE_W/2); label.setAttribute('y', NODE_H/2 + 1);
          label.setAttribute('class','node-label');
          label.textContent = `${node.n}/${node.d}`;

          const title = document.createElementNS('http://www.w3.org/2000/svg','title');
          title.textContent = `분수: ${node.n}/${node.d} (깊이 ${node.depth})\n클릭해서 경로 확인!`;
          
          g.append(rect, label, title);
          nodesFrag.appendChild(g);
        }
      }
      svg.appendChild(nodesFrag);
      
      const badge = document.createElementNS('http://www.w3.org/2000/svg','text');
      badge.setAttribute('x', width-12); badge.setAttribute('y', height-12);
      badge.setAttribute('text-anchor','end'); badge.setAttribute('class','badge');
      badge.textContent = 'AI교육연구회 : 위드석';
      svg.appendChild(badge);
    }

    // ---------- 컨트롤·상태 ----------
    const depthSel = $('#depthSel');
    const nodeW = $('#nodeW'); const nodeH = $('#nodeH');
    const btnRedraw = $('#btnRedraw'); const btnFit = $('#btnFit'); const btnSave = $('#btnSave');

    function currentType(){ return $$('input[name="treeType"]').find(r=>r.checked)?.value || 'cw' }
    function buildLevels(){
      const d = parseInt(depthSel.value,10);
      return currentType()==='cw' ? genCW(d) : genSB(d);
    }
    function redraw(){
      NODE_W = Math.max(40, Math.min(110, parseInt(nodeW.value,10)||60));
      NODE_H = Math.max(22, Math.min(70,  parseInt(nodeH.value,10)||28));
      clearHL();
      render(buildLevels());
    }

    // ---------- 검색/하이라이트/경로표시 ----------
    const findFrac = $('#findFrac'); const btnFind = $('#btnFind');
    const mapOut = $('#mapOut');

    function clearHL(){ $$('.node.hl', svg).forEach(n=>n.classList.remove('hl')); }
    function highlight(ab){
      clearHL();
      const target = $(`.node[data-frac="${ab}"]`, svg);
      if(target){
          target.classList.add('hl');
          return true;
      }
      return false;
    }
    btnFind.addEventListener('click', ()=>{
      const f = parseFrac(findFrac.value);
      if(!f){ alert('a/b 형태로 입력하세요 (분모 0 불가)'); return; }
      const ab = `${f[0]}/${f[1]}`;
      if(!highlight(ab)) alert('현재 깊이에서 찾을 수 없습니다. 깊이를 늘려보세요.');
      else {
        showPathForNode(f[0], f[1]);
      }
    });

    function showPathForNode(a,b) {
      if(currentType() !== 'cw') {
        mapOut.innerHTML = `경로 추적은 <b>칼킨-윌프 트리</b>에서만 지원됩니다.`;
        highlight(`${a}/${b}`);
        return;
      }
      const pathArr = getFracPath(a,b);
      const pathStr = pathArr.map(d => d==='L' ? '<b>왼쪽</b>' : '<b>오른쪽</b>').join(' → ');
      mapOut.innerHTML = `<b>${a}/${b}</b> 탐색 경로:<br>루트(1/1)에서 ${pathStr || '<b>도착!</b>'} 순서로 이동했어요.`;
      highlight(`${a}/${b}`);
      mapOut.style.backgroundColor = 'var(--brand-light)';
      setTimeout(() => { mapOut.style.backgroundColor = 'var(--bg)'; }, 1500);
    }

    // ---------- ℕ ↔ ℚ⁺ (Calkin–Wilf 경로 2진수) ----------
    function nToFrac(n){
      let a=1, b=1;
      const bits = n.toString(2).slice(1);
      for(const bit of bits){
        if(bit==='0'){ b = a + b; } else{ a = a + b; }
      }
      return [a,b];
    }
    function fracToN(a,b){
      [a,b] = simp(a,b);
      if(a<=0 || b<=0) return null;
      const path=[];
      while(!(a===1 && b===1)){
        if(a>b){ a -= b; path.push('1'); }
        else   { b -= a; path.push('0'); }
      }
      return parseInt('1' + path.reverse().join(''), 2);
    }
    function getFracPath(a,b) {
      [a,b] = simp(a,b);
      if(a<=0 || b<=0) return [];
      const path = [];
      while(!(a===1 && b===1)){
        if(a>b) { a -= b; path.push('R'); } // Right
        else { b -= a; path.push('L'); } // Left
      }
      return path.reverse();
    }

    const nInput = $('#nInput'), abInput=$('#abInput');
    const btnN2Q=$('#btnN2Q'), btnQ2N=$('#btnQ2N');

    btnN2Q.addEventListener('click', ()=>{
      const n = parseInt(nInput.value,10);
      if(!(n>=1)){ alert('n은 1 이상의 자연수'); return; }
      const [a,b] = nToFrac(n);
      const path = n.toString(2).slice(1).replace(/0/g,'L').replace(/1/g,'R') || '(루트)';
      abInput.value = `${a}/${b}`;
      mapOut.innerHTML = `자연수 <b>${n}</b> <span class="muted">(${n.toString(2)}₂)</span>의 짝꿍 분수는 <b>${a}/${b}</b> 입니다. <br>경로: <b>${path}</b>`;
      highlight(`${a}/${b}`);
    });
    btnQ2N.addEventListener('click', ()=>{
      const f = parseFrac(abInput.value);
      if(!f){ alert('a/b 형태로 입력'); return; }
      const [a,b]=f;
      if(a<=0||b<=0){ alert('양의 유리수만 (a>0, b>0)'); return; }
      const n = fracToN(a,b);
      const path = n.toString(2).slice(1).replace(/0/g,'L').replace(/1/g,'R') || '(루트)';
      nInput.value = n;
      mapOut.innerHTML = `분수 <b>${a}/${b}</b>의 짝꿍 자연수는 <b>${n}</b> <span class="muted">(${n.toString(2)}₂)</span> 입니다. <br>경로: <b>${path}</b>`;
      highlight(`${a}/${b}`);
    });

    // ---------- 목록(처음 N개) ----------
    const listN = $('#listN'); const btnList = $('#btnList'); const listTbl = $('#listTbl tbody');
    function buildList(N){
      const rows = [];
      for(let n=1;n<=N;n++){
        const [a,b]=nToFrac(n);
        const path = n.toString(2).slice(1).replace(/0/g,'L').replace(/1/g,'R') || '–';
        rows.push(`<tr><td>${n}</td><td>${a}/${b}</td><td>${(a/b).toFixed(6)}</td><td>${path}</td></tr>`);
      }
      listTbl.innerHTML = rows.join('');
    }
    btnList.addEventListener('click', ()=>{
      const N = Math.min(2048, Math.max(1, parseInt(listN.value,10)||32));
      buildList(N);
    });
    buildList(parseInt(listN.value,10));

    // ---------- 저장/화면맞춤/이벤트 ----------
    function saveSVG(){
        const svgEl = svg.cloneNode(true);
        const styleEl = document.createElement('style');
        styleEl.textContent = Array.from(document.styleSheets)
            .map(s => { try { return Array.from(s.cssRules).map(r => r.cssText).join('\n'); } catch { return ''; } })
            .join('\n');
        svgEl.insertBefore(styleEl, svgEl.firstChild);
        
        const src = new XMLSerializer().serializeToString(svgEl);
        const blob = new Blob(['<?xml version="1.0" standalone="no"?>\r\n', src], {type:'image/svg+xml;charset=utf-8'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'rational-tree.svg';
        a.click();
        setTimeout(() => URL.revokeObjectURL(a.href), 1000);
    }
    btnSave.addEventListener('click', saveSVG);

    function fitHeight(){
      const vh = Math.max(450, Math.min(720, Math.round(window.innerHeight * 0.64)));
      host.style.height = vh + 'px';
      redraw();
    }
    btnFit.addEventListener('click', fitHeight);

    btnRedraw.addEventListener('click', redraw);
    depthSel.addEventListener('change', redraw);
    nodeW.addEventListener('change', redraw);
    nodeH.addEventListener('change', redraw);
    $$('input[name="treeType"]').forEach(r=>r.addEventListener('change', redraw));
    
    let resizeTimer;
    window.addEventListener('resize', ()=>{
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(redraw, 150);
    });

    redraw();
  })();
  </script>
</body>
</html>